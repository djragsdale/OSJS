<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>OS JS</title>
        <script type="text/javascript" src="jquery-1.11.1.min.js"></script>
        <script type="text/javascript" src="MicrosoftAjax.js"></script>
        <script type="text/javascript" src="Prototype-1.6.0.js"></script>
        <script type="text/javascript" src="Ensure.js"></script>
    </head>
    <body>
        <canvas id="terminal" width="768" height="576" tabindex="0">
        </canvas>

        <div>
            <h1>Recognized commands (all uppercase)</h1>
            <ul>
                <li>HELP</li>
                <li>CLEAR</li>
                <li>ECHO <i>message</i></li>
                <li>LS</li>
                <li>LS <i>/directory</i></li>
                <li>CD ..</li>
                <li>CD <i>/directory</i></li>
                <li>BATCH HELLO-WORLD.BAT</li>
                <li>BATCH TEST.BAT</li>
                <li>BATCH VAR.BAT</li>
                <li>BATCH IF.BAT <i>number1</i> <i>number2</i></li>
                <li>BATCH LOOP.BAT <i>number</i></li>
                <li>EDIT test.TXT</li>
                <li>EDIT lorem.TXT</li>
            </ul>
        </div>

        <script id="runProgram"></script>


        <script>
            /*
            * CHECKLIST:
            * [ ] Can read/write 2 types of files: text (*.txt) and batch (*.bat) files.
            * [+] Saves those files in a database
            * [+] Saves location of file in database
            * [+] Saves file system structure in database (or XML file).
            * [ ] Can I make this OO and load in separated files?
            * [+]  - I should separate out essential programs (like batch, echo, pause, and clear).
            * [ ]  - I should also have a <strike>main file</strike> and a bootloader file, the only files which will directly
            *    mention the HTML document.
            * [+]  - Maybe have the "programs" written in actual JS, and when installing them you give the path to the JS file and it's saved in the DB.
            * [ ]  - Maybe write a real compiler for something simple like COBOL or BASIC that boils the programs down to JS?
            * [-]  - Evaluates complex expressions to true/false, a number, or concatenated string
            *
            * Ideas:
            *  - Have a computer object which handles physical output.
            *  - Have a keyboard class which contacts the computer (like the controller of the architecture). Inherits from IO which inherits from Device and logs interrupts with the OS.
            *  - Have an os class which is a property of the computer object.
            *  - The os class will run the bootloader then wait for computer input (listen on a computer's port).
            *  - Have programs interact with a hard drive object (which queries DB to "open files") which returns a JSON object containing program.
            *     + JSON object contains extension, mime type, array of "programs" registered to run it, and everything else can be expected that the program knows
            *       how to interact with it. For example, batch files will just have an additional array or the lines in the script.
            *  - Should I have a run program that can take executable file names as a parameter and then give control over
            *    to the respective program?
            *  - Don't forget to have the ability to make and remove directories (MKDIR and RMDIR), create, move, and delete files, and change and list contents of active directories (CD, LS).
            *  - How can a program take over what's on the screen without removing the past commands and responses
            *  - Now that the filesystem is navigable, should scripts only be runnable within their directories? Programs should be run in every directory, but parameters (like filename) should refer to locations relative to currentPath.
            */

            var terminal = document.getElementById("terminal");
            var tContext = terminal.getContext("2d");

            var width = 768;
            var height = 576;
            var maxLines = 28;
            var fontSize = 16;
            var bgColor = "#303030";
            var fgColor = "#FFFFFF";
            var cursorRow = -1;
            var cursorColumn = -1;
            var font = "Courier New";
            var lines = [];
            var currentPath = "/";
            var currentLine = "";
            var commands = [];
            var currentScript = [];
            var currentProgram = [];
            var programLoaded = false;
            var interrupt = null;
            var programControl = false;
            var DEBUG = true;
            var BASE_URL = "http://osjs.otiummusic.com/";

            var loadDefaultPrograms = function () {
                // Should probably run sql boot scripts loading the listed programs
                commands.push("HELP");
                commands.push("ECHO");
                commands.push("CLEAR");
                commands.push("BATCH");
                commands.push("PAUSE");
                //commands.push("HELLO");
                commands.push("LS");
                commands.push("CD");
                commands.push("MKDIR");
                commands.push("RMDIR");
                commands.push("RM");
                commands.push("EDIT");
                commands.push("PRINT");
                // commands.push("INPUT");
            };

            onload = function () {
                var i = 0;
                setInterval(function () {
                    if (i % 10 === 0) {
                        draw(i);
                    }
                    i++;
                    if (i > 100) { i = 0; }
                }, 8);

                loadDefaultPrograms();
            };

            var draw = function (frame) {
                tContext.clearRect(0, 0, width, height);
                tContext.fillStyle = bgColor;
                tContext.fillRect(0, 0, width, height);

                if (!programControl) {
                    tContext.moveTo(width * (0.02), height * (0.92));
                    tContext.lineTo(width * (0.98), height * (0.92));
                    tContext.strokeStyle = fgColor;
                    tContext.stroke();

                    if (frame > 49) {
                        writeLine(currentPath + "> " + currentLine + "_", width * (0.02), height * (0.97), bgColor, fgColor);
                    }
                    else { writeLine(currentPath + "> " + currentLine, width * (0.02), height * (0.97), bgColor, fgColor); }
                }

                for (var i = 0; i < lines.length; i++) {
                    for (var j = 0; j < lines[i].length; j++) {
                        if (i == cursorRow && j == cursorColumn) {
                            writeLine(lines[i][j], width * (0.02) + j * (fontSize * 0.6), height * (0.07) + (i * (fontSize * 1.08)), fgColor, bgColor);
                        }
                        else {
                            writeLine(lines[i][j], width * (0.02) + j * (fontSize * 0.6), height * (0.07) + (i * (fontSize * 1.08)), bgColor, fgColor);
                        }
                    }
                }
            };

            var writeLine = function (text, x, y, backColor, foreColor) {
                // Handle the cursor possibility first
                if (backColor != bgColor) {
                    tContext.fillRect(x, y - (fontSize * 0.8), (fontSize * 0.6), (fontSize * 1.1));
                }
                tContext.font = fontSize + "px " + font;
                tContext.fillStyle = foreColor;
                tContext.fillText(text, x, y);
            };

            var addLine = function (text) {
                lines.push(text);
                if (lines.length > maxLines) {
                    for (var i = 0; i < lines.length; i++) {
                        lines[i] = lines[i + 1];
                    }
                    lines.pop();
                }
            };

            var pause = function (seconds) {
                // Calling this function doesn't actually stop execution of the next line because it naturally multithreads.
                if (!isNaN(parseFloat(seconds))) {
                    var i = 0;
                    var max = seconds * 100;
                    var _pause = setInterval(function () {
                        if (i < max) {
                            i++;
                        } else {
                            // addLine("CLEARING INTERVAL.");
                            clearInterval(_pause);
                        }
                    }, 10);
                    return 1;
                } else {
                    addLine("PAUSE ERROR: NAN.");
                    return 0;
                }
            };

            var evaluate = function (expression, tokenList) {
                // Order of evaluation

                // First thing: remove whitespace unless in a string (for concatenation)
                var newExpression = "";
                var override = false;
                for (var i = 0; i < expression.length; i++) {
                    if (override) {
                        newExpression += expression[i];
                    } else {
                        if (expression[i] != ' ') {
                            newExpression += expression[i];
                        }
                    }
                    if (expression[i] == '"') {
                        if (!override) {
                            override = true;
                        } else {
                            override = false;
                        }
                    }
                }

                // Base cases:
                if (/^([0-9]*)$/.test(newExpression)) {
                    // Is single number?
                }
                else if (true) {
                    // Is single variable?
                }
                else if (/^([A-Za-z]*)$/.test(newExpression)) {
                    // Is single string?
                }



            }

            var evaluateExpression = function (expression, tokenList) {

                var newExpression = "";
                var nonBoolean = true;

                //console.log("newExpression before anything: " + newExpression);

                var result = false;

                // For precedence, should do separate runs for operations order after replacing variables and removing whitespace
                // Doesn't handle negatives or floats
                // Can I short-circuit this if a single term?

                // Replace variables and remove whitespace (unless in a string)
                // COMPLETE, UNTESTED
                var override = false;
                for (var i = 0; i < expression.length; i++) {
                    if (override) {
                        newExpression += expression[i];
                    } else {
                        if (expression[i] == '$') {
                            var varName = expression[i + 1];
                            i++;
                            while (/^([A-Za-z0-9]*)$/.test(expression[i + 1])) {
                                varName += expression[i + 1];
                                i++;
                            }

                            // Make sure variable name exists, capture if it does
                            var nameExists = false;
                            var varVal;
                            for (var j = 0; j < tokenList.length; j++) {
                                if (tokenList[j].key == varName) {
                                    nameExists = true;
                                    varVal = tokenList[j].value;
                                    j = tokenList.length;
                                }
                            }
                            if (nameExists) {
                                newExpression += varVal;
                                //set new i
                                // var $something
                                // let $something = 8375
                                // 7 + $something - 4
                                // 7+ $something - 4
                                // 7+$something - 4
                                // 7+8375 - 4
                                // 7+8375- 4
                                // 7+8375-4
                                i = i + varVal.length - 1;
                            } else {
                                addLine("Error when parsing expression: variable '$" + varName + "' does not exist.");
                                i = expression.length;
                            }
                        }
                        else if (expression[i] != ' ') {
                            newExpression += expression[i];
                        }
                    }
                    if (expression[i] == '"') {
                        if (!override) {
                            override = true;
                        } else {
                            override = false;
                        }
                    }
                }

                //console.log("newExpression after variable replacement: " + newExpression);

                // Recurse through parentheses
                // COMPLETE, UNTESTED
                for (var i = 0; i < newExpression.length; i++) {
                    if (newExpression[i] == ' ') {
                        // Leave empty so we ignore spaces in case they slipped through somehow
                        // TODO: Later remove for performance gain
                    }
                    else if (newExpression[i] == '(') {
                        // extract segment from parentheses and recursively call that segment
                        var openParens = 0;
                        for (var j = i + 1; j < newExpression.length; j++) {
                            if (newExpression[j] == ')') {
                                if (openParens == 0) {
                                    // get subResult
                                    //addLine("Time to get subresult...");
                                    var subResult = evaluateExpression(newExpression.substring(i + 1, j), tokenList);
                                    //addLine("subresult=" + subResult);
                                    // insert subResult into expression
                                    newExpression = newExpression.substring(0, i) + subResult + newExpression.substring(j + 1, newExpression.length);
                                    // set j
                                    j = newExpression.length;
                                    // set i
                                    i = i + subResult.length - 1;
                                } else {
                                    openParens--;
                                }
                            }
                            else if (newExpression[j] == '(') {
                                openParens++;
                            }
                        }
                    }
                    else if (newExpression[i] == ')') {
                        //addLine("An error occurred while parsing conditional expression.");
                        return false;
                    }
                }

                //console.log("newExpression after parentheses check: " + newExpression);

                // Do multiplication, division, and modulos, no exponents allowed for now
                // INCOMPLETE, UNTESTED
                // Currently doesn't handle negative numbers
                // Test case: (2 + (3 - 1) * (3 + 14 - 10)) / 4 % 9
                for (var i = 0; i < newExpression.length; i++) {
                    if (newExpression[i] == '*') {
                        // If followed by minus, multiply by the following number *-1
                        var term0 = "";
                        var term1 = "";

                        // Make sure preceded by a number
                        if (/^([0-9]*)$/.test(newExpression[i - 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i - 1 - term0.length])) {
                                term0 = newExpression[i - 1 - term0.length] + term0;
                            }
                        } else {
                            addLine("An error occurred while parsing expression. * preceded by NaN.");
                        }
                        if (/^([0-9]*)$/.test(newExpression[i + 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i + 1 + term1.length])) {
                                term1 += newExpression[i + 1 + term1.length];
                            }
                        } else {
                            addLine("An error occurred while parsing expression. * followed by NaN.");
                        }

                        var subResult = term0 * term1;

                        // Replace text with new values and set i
                        newExpression = newExpression.substring(0, i - term0.length) + subResult + newExpression.substring(i + term1.length + 1, newExpression.length);
                        i = i - term0.length + (subResult + "").length - 1;
                    }
                    else if (newExpression[i] == '/') {
                        // If followed by minus, divide by the following number *-1
                        var term0 = "";
                        var term1 = "";

                        // Make sure preceded by a number
                        if (/^([0-9]*)$/.test(newExpression[i - 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i - 1 - term0.length])) {
                                term0 = newExpression[i - 1 - term0.length] + term0;
                            }
                        } else {
                            addLine("An error occurred while parsing expression. / preceded by NaN.");
                        }
                        if (/^([0-9]*)$/.test(newExpression[i + 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i + 1 + term1.length])) {
                                term1 += newExpression[i + 1 + term1.length];
                            }
                        } else {
                            addLine("An error occurred while parsing expression. / followed by NaN.");
                        }

                        var subResult = term0 / term1;

                        // Replace text with new values and set i
                        newExpression = newExpression.substring(0, i - term0.length) + subResult + newExpression.substring(i + term1.length + 1, newExpression.length);
                        i = i - term0.length + (subResult + "").length - 1;
                    }
                    else if (newExpression[i] == '%') {
                        var term0 = "";
                        var term1 = "";

                        // Make sure preceded by a number
                        if (/^([0-9]*)$/.test(newExpression[i - 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i - 1 - term0.length])) {
                                term0 = newExpression[i - 1 - term0.length] + term0;
                            }
                        } else {
                            addLine("An error occurred while parsing expression. % preceded by NaN.");
                        }
                        if (/^([0-9]*)$/.test(newExpression[i + 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i + 1 + term1.length])) {
                                term1 += newExpression[i + 1 + term1.length];
                            }
                        } else {
                            addLine("An error occurred while parsing expression. % followed by NaN.");
                        }

                        var subResult = term0 % term1;

                        // Replace text with new values and set i
                        newExpression = newExpression.substring(0, i - term0.length) + subResult + newExpression.substring(i + term1.length + 1, newExpression.length);
                        i = i - term0.length + (subResult + "").length - 1;
                    }
                }

                //console.log("newExpression after */% check: " + newExpression);

                // Do addition and subtraction
                // INCOMPLETE, UNTESTED
                for (var i = 0; i < newExpression.length; i++) {
                    if (newExpression[i] == '+') {
                        // If followed by minus, add the following number *-1
                        var term0 = "";
                        var term1 = "";

                        // Make sure preceded by a number
                        if (/^([0-9]*)$/.test(newExpression[i - 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i - 1 - term0.length])) {
                                term0 = newExpression[i - 1 - term0.length] + term0;
                            }
                        } else {
                            addLine("An error occurred while parsing expression. + preceded by NaN.");
                        }
                        if (/^([0-9]*)$/.test(newExpression[i + 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i + 1 + term1.length])) {
                                term1 += newExpression[i + 1 + term1.length];
                            }
                        } else {
                            addLine("An error occurred while parsing expression. + followed by NaN.");
                        }

                        var subResult = parseFloat(term0) + parseFloat(term1);

                        // Replace text with new values and set i
                        newExpression = newExpression.substring(0, i - term0.length) + subResult + newExpression.substring(i + term1.length + 1, newExpression.length);
                        i = i - term0.length + (subResult + "").length - 1;
                    }
                    else if (newExpression[i] == '-') {
                        // If followed by minus, subtract by the following number *-1
                        var term0 = "";
                        var term1 = "";

                        // Make sure preceded by a number
                        if (/^([0-9]*)$/.test(newExpression[i - 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i - 1 - term0.length])) {
                                term0 = newExpression[i - 1 - term0.length] + term0;
                            }
                        } else {
                            addLine("An error occurred while parsing expression. - preceded by NaN.");
                        }
                        if (/^([0-9]*)$/.test(newExpression[i + 1])) {
                            while (/^([0-9]*)$/.test(newExpression[i + 1 + term1.length])) {
                                term1 += newExpression[i + 1 + term1.length];
                            }
                        } else {
                            addLine("An error occurred while parsing expression. - followed by NaN.");
                        }

                        var subResult = term0 - term1;

                        // Replace text with new values and set i
                        newExpression = newExpression.substring(0, i - term0.length) + subResult + newExpression.substring(i + term1.length + 1, newExpression.length);
                        i = i - term0.length + (subResult + "").length - 1;
                    }
                }

                //console.log("newExpression after +- check: " + newExpression);

                // Check for boolean expression
                // INCOMPLETE, UNTESTED
                // I need to factor in existing result somehow in case there are mutliple boolean operators per line

                for (var i = 0; i < newExpression.length; i++) {
                    if (newExpression[i] == '<' && newExpression[i + 1] == '>') {
                        nonBoolean = false;
                        //addLine("Evaluating <> on " + newExpression);

                        if (evaluateExpression(newExpression.substring(0, i), tokenList) != evaluateExpression(newExpression.substring(i + 2, newExpression.length))) {
                            //addLine(newExpression + " evaluates TRUE");
                            result = true;
                        } else {
                            //addLine(newExpression + " evaluates FALSE");
                            result = false;
                        }
                        i++;
                    }
                    else if (newExpression[i] == '<') {
                        nonBoolean = false;

                        if (evaluateExpression(newExpression.substring(0, i), tokenList) < evaluateExpression(newExpression.substring(i + 1, newExpression.length))) {
                            //addLine(newExpression + " evaluates TRUE");
                            result = true;
                        } else {
                            //addLine(newExpression + " evaluates FALSE");
                            result = false;
                        }
                    }
                    else if (newExpression[i] == '=' && newExpression[i + 1] == '=') {
                        nonBoolean = false;
                        // No assignment allowed inside expressions for now
                        if (evaluateExpression(newExpression.substring(0, i), tokenList) == evaluateExpression(newExpression.substring(i + 2, newExpression.length))) {
                            //addLine(newExpression + " evaluates TRUE");
                            result = true;
                        } else {
                            //addLine(newExpression + " evaluates FALSE");
                            result = false;
                        }
                        //result = evaluateExpression(newExpression.substring(0, i), tokenList) == evaluateExpression(newExpression.substring(i+2, newExpression.length));

                        i++;
                    }
                    else if (newExpression[i] == '!' && newExpression[i + 1] == '=') {
                        nonBoolean = false;
                        // Peek to see if next character is '='
                        // If so, check if things do not equal
                        // If not, throw error (for now no boolean inversion is supported)

                        if (evaluateExpression(newExpression.substring(0, i), tokenList) != evaluateExpression(newExpression.substring(i + 2, newExpression.length))) {
                            //addLine(newExpression + " evaluates TRUE");
                            result = true;
                        } else {
                            //addLine(newExpression + " evaluates FALSE");
                            result = false;
                        }

                        i++;
                    }
                    else if (newExpression[i] == '>') {
                        nonBoolean = false;

                        if (evaluateExpression(newExpression.substring(0, i), tokenList) > evaluateExpression(newExpression.substring(i + 1, newExpression.length))) {
                            //addLine(newExpression + " evaluates TRUE");
                            result = true;
                        } else {
                            //addLine(newExpression + " evaluates FALSE");
                            result = false;
                        }
                    }
                    else if (newExpression[i] == '&' && newExpression[i + 1] == '&') {
                        nonBoolean = false;
                        // Peek to see if next character is '&'
                        // Then do truth tables on evaluateExpression of left half vs. right half
                        // If just a number on one side, evaluate as 0=false and everything else being true

                        i++;
                    }
                    else if (newExpression[i] == '|' && newExpression[i + 1] == '|') {
                        nonBoolean = false;
                        // Peek to see if next character is '|'
                        // Then do truth tables on evaluateExpression of left half vs. right half
                        // If just a number on one side, evaluate as 0=false and everything else being true

                        i++;
                    }
                }

                //console.log("newExpression after boolean check: " + newExpression);

                // Check to see type of result.
                // If a string or number, return newExpression (or set result as newExpression).
                // If a boolean value, return result.
                if (nonBoolean == true) {
                    //addLine("newExpression is nonBoolean");
                    result = newExpression;
                } else {
                    //addLine("newExpression is Boolean");
                }

                return result;
            };

            var clearLine = function () {
                lines.pop();
            };

            var clearAllLines = function () {
                lines = [];
            };

            var testExtension = function (file, requestedExtension) {
                var periodReached = false;
                var extension = "";
                for (var i = 0; i < file.length; i++) {
                    if (periodReached) {
                        extension += file[i];
                    }
                    if (file[i] == ".") {
                        periodReached = true;
                    }
                }
                if (extension == requestedExtension) {
                    return true;
                } else {
                    return false;
                }
            };

            var loadProgram = function (programTitle) {
                // push each line to the currentScript variable
                // do a SQL search for the programTitle ordered by the lineNbr
                currentProgram = [];
                if (programTitle == "ECHO") {
                    // Go ahead and figure out the code for the Echo program
                    // but I can use this for now
                    // currentScript.push("addLine(%param1%);");
                }
                else if (programTitle == "BATCH") {

                }
                else if (programTitle == "PAUSE") {

                }
                else if (programTitle == "CLEAR") {

                }
                else if (programTitle == "HELP") {
                    addLine('Querying filesystem for program...');
                    $.getScript(BASE_URL + 'getProgram.php?q=HELP', function () {
                        addLine('...HELP program loaded.');
                        programLoaded = true;
                    });
                    //var scriptHolder = document.getElementById('scrProgram');
                    //scriptHolder.innerHTML =
                    //addLine('LIST OF RECOGNIZED COMMANDS:');
                    //addLine('- HELP [command]');
                    //addLine('- CLEAR');
                    //addLine('- ECHO "MESSAGE"');
                    //addLine('- BATCH FILENAME.BAT [params...]')
                    //addLine('');
                }

            };

            var parseLine = function (line) {
                // When I add the ability to declare functions, will need a 2-pass parser
                // Since I'm not allowing functions, the first run of finding function tokens is moot
                // Attempting to use a Recursive Descent Parser
                // Reference: www.incubatorgames.com/index.php/20110121/simple-scripting-language-part-4/
                // Looks like I may have to use the first pass after all, since I'm using variables to capture input.
                // I think I'll skip capturing input in scripts until the second pass is tested and works.

                // Order:
                // Identify a token
                // Find the ID that represents the variable name
                // Check that another variable by this name hasn't already been declared in this scope
                // If value is initialized then match it with it's value

                // Summary:
                // The first pass creates a dictionary of objects found in the file keyed by the file signature
                // The second pass creates variables and inserts code to reference variables later on-
                // Will replace variable names with numbers, so *MYNUMBER will become *0 (index 0 of token list)
                //   if it's the first variable needed.

                // Not even sure if I want to do this, maybe I'll just parse on the fly and skip
                // any element of compiling (since I'm going to javascript)
                // I'll still use a token

            };

            var lexLine = function (text) {
                // Lex the line
                // group "..." and (...)
                var line = [];
                var word = "";
                var override = false;
                for (var i = 0; i < text.length; i++) {
                    if (text[i] == '"') {
                        i++;
                        override = true;
                        // just start a while loop and override j variable at end (don't lose count of position!)
                        while (override) {
                            if (text[i] == '"') {
                                // addLine("Found closing quote.");
                                line.push(word);
                                word = "";
                                override = false;
                            } else {
                                // addLine("Found character " + text[i] + " in quotes.");
                                word += text[i];
                            }

                            i++;
                        }
                    }
                    else if (text[i] == '(') {
                        word += text[i];
                        i++;
                        override = true;
                        // just start a while loop and override j variable at end (don't lose count of position!)
                        while (override) {
                            word += text[i];
                            if (text[i] == ')') {
                                // addLine("Found closing paren.");
                                line.push(word);
                                word = "";
                                override = false;
                            }
                            i++;
                        }
                    }
                    else {
                        if (text[i] != " ") {
                            word += text[i];
                            if (i + 1 == text.length) {
                                // addLine("Word added due to EOL.");
                                line.push(word);
                            }
                        } else {
                            // addLine("Word added due to space.");
                            line.push(word);
                            word = "";
                        }
                    }
                }

                return line;
            }

            var dbRequest = function (query) {
                //var xmlhttp;
                if (query == "") {
                    addLine("A SQL error occurred.");
                    return;
                } else {
                    addLine("Querying filesystem for " + query + "...");
                }
                if (window.XMLHttpRequest) {
                    xmlhttp = new XMLHttpRequest();
                } else {
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }
                xmlhttp.onreadystatechange = function () {
                    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                        var results = JSON.parse(xmlhttp.responseText);
                        for (var i = 0; i < results.length; i++) {
                            addLine(results[i]);
                        }
                    }
                };
                xmlhttp.open("GET", BASE_URL + "getScript.php?q=" + query, true);
                xmlhttp.send();
            };

            var loadScript = function (fileName) {
                if (testExtension(fileName, "BAT")) {
                    if (DEBUG) { addLine("LOADING " + fileName + "."); }

                    currentScript = [];

                    if (fileName.substring(0, fileName.length - 4) == "") {
                        addLine("An error occurred while loading script: invalid file name.");
                    } else {
                        if (DEBUG) { addLine("Querying filesystem for " + fileName + "..."); }
                    }

                    if (window.XMLHttpRequest) {
                        xmlhttp = new XMLHttpRequest();
                    } else {
                        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                    }

                    xmlhttp.open("GET", BASE_URL + "getScript.php?q=" + fileName.substring(0, fileName.length - 4), false);
                    xmlhttp.send();

                    var results = JSON.parse(xmlhttp.responseText);

                    for (var i = 0; i < results.length; i++) {
                        currentScript.push(results[i]);
                    }

                    if (results.length > 0) {
                        if (DEBUG) { addLine("..." + fileName + " loaded."); }
                    } else {
                        addLine("File loading error occurred: file does not exist.");
                    }

                    //if (fileName == "TEST.BAT") {
                    //    addLine("Loading sample script...");
                    //
                    //    // I just hardcoded this sample batch script for testing purposes.
                    //    //currentScript = [];
                    //    currentScript.push('BEGIN "HELLO-WORLD"');
                    //    currentScript.push("ECHO HELLO");
                    //    currentScript.push("PAUSE 2");
                    //    currentScript.push("ECHO WORLD");
                    //    currentScript.push("PAUSE 1");
                    //    currentScript.push("ECHO !");
                    //    currentScript.push("PAUSE 1");
                    //    currentScript.push('ECHO "ALTOGETHER NOW..."');
                    //    currentScript.push("PAUSE 2");
                    //    currentScript.push('ECHO "HELLO, WORLD!"');
                    //    currentScript.push("EXIT");
                    //
                    //    addLine("...Sample script loaded.");
                    //}
                    //else if (fileName == "IF.BAT") {
                    //    addLine("Loading sample conditional script...");
                    //
                    //    currentScript.push('BEGIN "CONDITIONAL-TEST"');
                    //    currentScript.push('ECHO "HELLO, WORLD!"');
                    //    currentScript.push('IF #1 < #2');
                    //    currentScript.push('GOTO 6');
                    //    currentScript.push('GOTO 8');
                    //    currentScript.push('ECHO "#1 IS LESS THAN #2"');
                    //    currentScript.push('GOTO 10');
                    //    currentScript.push('ECHO "#1 IS NOT LESS THAN #2"');
                    //    currentScript.push('GOTO 10');
                    //    currentScript.push('ECHO "FINISHED PROCESSING CONDITIONAL."');
                    //    currentScript.push('ECHO GOODBYE!');
                    //    currentScript.push('EXIT "CONDITIONAL-TEST"');
                    //
                    //    addLine("...Sample conditional script loaded.");
                    //}
                    //else if (fileName == "VAR.BAT") {
                    //    addLine("Loading sample variable script...");
                    //
                    //    currentScript.push('BEGIN "VARIABLE-TEST"');
                    //    currentScript.push('ECHO "HELLO, WORLD!"');
                    //    currentScript.push('ECHO "VARIABLE $VAR1 = 4"');
                    //    currentScript.push('VAR $VAR1');
                    //    currentScript.push('LET $VAR1 = 4');
                    //    currentScript.push('ECHO "ECHOING $VAR1"');
                    //    currentScript.push('ECHO $VAR1');
                    //    currentScript.push('ECHO "SUCCESS!"');
                    //    currentScript.push('EXIT "VARIABLE-TEST"');
                    //
                    //    addLine("...Sample variable script loaded.");
                    //}
                    //else if (fileName == "LOOP.BAT") {
                    //    addLine("Loading sample loop script...");
                    //
                    //    currentScript.push('BEGIN "LOOP-TEST"');
                    //    currentScript.push('ECHO "LOOP TEST BEGINNING..."');
                    //    currentScript.push('VAR $VAR1');
                    //    currentScript.push('LET $VAR1 = 0');
                    //    currentScript.push('ECHO "ECHOING HELLO WORLD #1 TIMES"');
                    //    currentScript.push('IF $VAR1 < #1');
                    //    currentScript.push('GOTO 9');
                    //    currentScript.push('GOTO 12');
                    //    currentScript.push('ECHO "HELLO, WORLD!"');
                    //    currentScript.push('LET $VAR1 = $VAR1 + 1');
                    //    currentScript.push('GOTO 6');
                    //    currentScript.push('ECHO "DONE LOOPING."');
                    //    currentScript.push('ECHO "SUCCESS!"');
                    //    currentScript.push('EXIT "LOOP-TEST"');
                    //
                    //    addLine("...Sample loop script loaded.");
                    //}
                    //else {
                    //    // TODO: look for script in DB
                    //
                    //    addLine("FILE NOT FOUND.");
                    //}
                } else {
                    addLine("INVALID FILE EXTENSION.");
                }
            }

            var executeCommand = function (command) {
                //var params = command.split(' ');
                var params = lexLine(command);
                // Doesn't work yet
                //loadProgram(params[0]);
                if (DEBUG) { addLine('Querying filesystem for program...'); }
                //$.getScript('getProgram.php?q=HELP', function () {
                //    programLoaded = true;
                //    addLine('...' + params[0] + ' program loaded.');
                //    console.log('about to run main()');
                //    var params = [];
                //    main(params);
                //});
                // Append query string so the request appears unique, otherwise ensure will just use the one already loaded.
                ensure({ js: BASE_URL + "getProgram.php?q=" + params[0] + "&n=" + Math.random() }, function () {
                    //if (errored) {
                    //    addLine("..." + params[0] + " program does not exist.");
                    //}
                    //else {
                    //var newParams = [];
                    if (DEBUG) {
                        addLine('...' + params[0] + ' program loaded.');
                        console.log('about to run main()');
                    }
                    try {
                        main(params);
                    } catch (exc) {
                        addLine("Error.");
                    }
                    //main = undefined;
                    //}
                });

                console.log("running command " + params[0] + ".");

                //var runCount = 0;
                //var maxRuns = 5000;
                console.log("program is loaded.");
                //console.log("programLoaded=" + programLoaded);
                //console.log("runCount=" + runCount);

                var testing = false;
                if (testing) {
                    // should execute the program, but currently I'll use this
                    if ((command.length > 4) && (params[0] == "ECHO")) {
                        var strLine = command.substring(5);
                        var word = params[1];

                        addLine(word);
                    }
                    else if (params[0] == "HELP") {
                        addLine("Generating help commands...");
                        if (command.length > 4) {
                            addLine('LIST OF RECOGNIZED COMMANDS:');
                            addLine('- HELP [command]');
                            addLine('- CLEAR');
                            addLine('- ECHO "MESSAGE"');
                            addLine('- BATCH FILENAME.BAT [params...]')
                            addLine('');
                        }
                        else {
                            var params = [];
                            console.log('about to run main()');
                            main(params);
                            //addLine('LIST OF RECOGNIZED COMMANDS:');
                            //addLine('- HELP [command]');
                            //addLine('- CLEAR');
                            //addLine('- ECHO "MESSAGE"');
                            //addLine('- BATCH FILENAME.BAT [params...]')
                            //addLine('');
                        }
                    }
                    else if ((command.length > 5) && (params[0] == "PAUSE")) {
                        //pause(3);
                        //setInterval(function () { addLine("PAUSE"); }, 3000);
                    }
                    else if (params[0] == "CLEAR") {
                        clearAllLines();
                    }
                    else if ((command.length > 5) && (params[0] == "BATCH") && (testExtension(params[1], "BAT"))) {
                        // Need to load the script first!
                        loadScript(params[1]);
                        var scriptTitle = "";
                        var tokenList = [];

                        var began = false;
                        for (var i = 0; i < currentScript.length; i++) {
                            // Parse the line
                            var strLine = currentScript[i];
                            var line = lexLine(strLine);

                            // Preprocessing to replace parameter AND VARIABLE references
                            // line[j] is the word in the line
                            for (var j = 0; j < line.length; j++) {
                                for (var k = 0; k < line[j].length; k++) {
                                    if (line[j][k] == '#') {
                                        var paramNum = parseInt(line[j][k + 1]);
                                        if ((paramNum > 9) || (paramNum < 1)) {
                                            addLine("ERROR PARSING PARAMETER ON LINE " + (i + 1) + ".");
                                            i = currentScript.length;
                                        }
                                        else if (k == 0) {
                                            var newString = parseInt(params[paramNum + 1]) + line[j].substring(2, line[j].length);
                                            line[j] = newString;
                                        }
                                        else if (line[j][k - 1] != '\\') {
                                            // addLine("FIRST PART:" + line[j].substring(0, k) + " SECOND PART:" + parseInt(params[paramNum + 1]) + " THIRD PART:" + line[j].substring((k + 2), line[j].length) + ".");
                                            var newString = line[j].substring(0, k) + parseInt(params[paramNum + 1]) + line[j].substring((k + 2), line[j].length);
                                            line[j] = newString;
                                        }
                                    }
                                }

                                // Check for variables
                                if (line[j][0] == '$') {
                                    if ((line[0] == 'ECHO') || (line[0] == 'IF')) {
                                        //addLine("Searching for variable...");
                                        var tokenIndex;
                                        var varName = line[j].substring(1, line[j].length);

                                        for (var k = 0; k < tokenList.length; k++) {
                                            if (tokenList[k].key == varName) {
                                                line[j] = tokenList[k].value;
                                                //addLine("VARIABLE $" + line[j] + " BEING REPLACED.");
                                                k = tokenList.length;
                                            }
                                        }
                                    }
                                }
                            }

                            /* Run the commands
                            * Define my script language which BATCH can run (-word- indicates low priority):
                            * start with BEGIN "program-name"
                            * -PAUSE-
                            * INPUT captures user input w/ 2 parameters: variable name, prompt for user
                            * ECHO captures only the first following parameter, but includes everything in ""'s
                            * REM indicates comments
                            * IF has 3 parameters: item0, operator, item1
                            * ELSE has no parameters
                            * ENDIF has no parameters
                            * -WHILE- has 3 parameters: item0, operator, item1
                            * -ENDWHILE- has no parameters
                            * VAR has 1 parameter: variable name
                            * LET has 3 parameters: variable, '=', and variable/integer/string
                            *   - Will need to eventually work with expressions
                            * GOTO  has 1 parameter: line nbr to go to next. If inside an IF, end the IF then go to line
                            * EXIT ends the program, anything after is ignored (typically follow with "program-name")
                            * needs an outlet for errors
                            *
                            *
                            * Ideas:
                            * To keep blocks organized use a stack.
                            *   - When end of a block is reached, peek at the top of the stack and see
                            *     if the block types match. If a ENDWHILE is matched against an IF, then
                            *     something has gone wrong and an error can be thrown.
                            */
                            if ((i == 0) && (line[0] == "BEGIN")) {
                                began = true;
                                scriptTitle = line[1];
                                addLine("BEGINNING " + scriptTitle + " SCRIPT.");
                            }
                            else if (i == 0) {
                                // BEGIN has to be on the first line or entire thing fails.
                                addLine("BEGIN COMMAND MISSING ON FIRST LINE.");
                                i = currentScript.length;
                            }
                            else if (line[0] == "EXIT") {
                                addLine("EXITING " + scriptTitle + " SCRIPT.");
                                i = currentScript.length;
                            }
                            //else if (line[0] == "INPUT") {
                            //    // parameter 1: variable name to capture into
                            //    // parameter 2: prompt string to give to user
                            //}
                            else if (line[0] == "PAUSE") {
                                pause(3);
                                //var result = pause(line[1]);
                                //if (result == 1) {
                                //    i = currentScript.length;
                                //}
                            }
                            else if (line[0] == "ECHO") {
                                addLine(line[1]);
                            }
                            else if (line[0] == "REM") {

                            }
                            else if (line[0] == "GOTO") {
                                // Subtract 1 so that user can start counting at line 1 instead of line 0.
                                // Subtract 1 again so that when i++ runs it goes to correct line :).
                                i = line[1] - 2;
                            }
                            else if (line[0] == "IF") {
                                // take the conditional, add another for loop that parses through the next loop (recursion?)
                                // Nope, just do all on same line and use GOTOs

                                // Evaluate the conditional. If so, GOTO i+1. If not, GOTO i+2.
                                // Each can essentially act as a block by using GOTOs.

                                // Sorta works if numbers are in there, but this probably works
                                // alphabetically and also doesn't search for parameters.
                                // TODO: Fix to work with numbers and parameters

                                // Now how does this work if running the first line (operated TRUE), how can I skip the second line?
                                // Maybe the scripter just has to know to only use GOTOs after conditionals then GOTO back after the 2nd line?

                                // If the parser goes through and replaces all valid tokens with values and all conditional operations with TRUE
                                // or FALSE this might be a little easier. So the parser does the math? Maybe even replace the conditional blocks
                                // and GOTOs? So it renders straight script?
                                // Mark parameters by beginning with # and number (i.e. #1), then replace those in the code in the parser
                                // (as long as not preceded by the '\' escape character)?
                                // That would allow 9 total parameters after the filename.

                                // I should use evaluateExpression instead so I can use recursion

                                // addLine('PARAM1:' + line[1] + ' PARAM2:' + line[2] + ' PARAM3:' + line[3]);

                                //if (line[2] == "==") {
                                //    if (line[1] == line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == "<") {
                                //    if (line[1] < line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == ">") {
                                //    if (line[1] > line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == "!=") {
                                //    if (line[1] != line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == "<=") {
                                //    if (line[1] <= line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == ">=") {
                                //    if (line[1] >= line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else if (line[2] == "<>") {
                                //    if (line[1] != line[3]) {
                                //
                                //    } else {
                                //        i++;
                                //    }
                                //}
                                //else {
                                //    addLine("INVALID CONDITIONAL SYNTAX AT LINE " + (i + 1) + ".");
                                //    i = currentScript.length;
                                //}

                                // Append all the remaining things together
                                var ifExpression = "";
                                for (var j = 1; j < line.length; j++) {
                                    ifExpression += line[j];
                                }

                                var ifResult = evaluateExpression(ifExpression);

                                if (ifResult == true) {
                                    // Nothing happens because I'm going to run my next line
                                } else {
                                    // i is incremented to get to the ELSE line
                                    i++;
                                }
                            }
                            //else if (line[0] == "ELSE") {
                            //    // same as before...
                            //}
                            //else if (line[0] == "ENDIF") {
                            //    // what do I do to end an IF?
                            //}
                            else if (line[0] == "VAR") {
                                // Make sure variable name doesn't already exist
                                //  - If it doesn't, pop it to the token list
                                //  - If it does, add error and end script

                                var varName = line[1].substring(1, line[1].length);
                                var exists = false;
                                for (var j = 0; j < tokenList.length; j++) {
                                    if (tokenList[j].key == varName) { exists = true; }
                                }

                                //addLine("VARIABLE EXISTS: " + exists);

                                if (!exists) {
                                    tokenList.push({
                                        key: varName,
                                        value: ""
                                    });
                                    //addLine("VARIABLE $" + varName + " DOES NOT EXIST. NEW VARIABLE CREATED.");
                                    //addLine("TokenList: ");
                                    //for (j = 0; j < tokenList.length; j++) {
                                    //    addLine(tokenList[j].key + ", " + tokenList[j].value);
                                    //}
                                } else {
                                    //addLine("VARIABLE NAME '$" + varName + "' ON LINE " + (i + 1) + " ALREADY EXISTS.");
                                    i = currentScript.length;
                                }
                            }
                            else if (line[0] == "LET") {
                                // Make sure variable name exists
                                // If it does, check type of 3rd parameter
                                // - If it's a string or number set the token list item value to it
                                // - If it's a variable,
                                // TODO: Let this work with expressions
                                // - Should expressions evaluate off a stack? This way it can do math with parentheses.

                                if (line[2] == '=') {
                                    var varName0Exists = false;
                                    var varName0 = line[1].substring(1, line[1].length);
                                    var varName0Index;
                                    //var varName1Exists = false;
                                    //var varName1IsVariable = false;
                                    //var var1 = line[3];
                                    //var varName1 = line[3].substring(1, line[3].length);
                                    //var varName1Index;

                                    //if (varName1[0] == '$') { varName1IsVariable = true; }

                                    // Make sure variable name exists
                                    for (var j = 0; j < tokenList.length; j++) {
                                        if (tokenList[j].key == varName0) {
                                            varName0Exists = true;
                                            varName0Index = j;
                                            //addLine("tokenList[" + j + "] = { " + tokenList[j].key + ", " + tokenList[j].value + "};");
                                        }
                                        //else if ((varName1IsVariable == true) && (tokenList[j].key = varName1)) {
                                        //    varName1Exists = true;
                                        //    varName1Index = j;
                                        //    //addLine("tokenList[" + j + "] = { " + tokenList[j].key + ", " + tokenList[j].value + "};");
                                        //}
                                    }

                                    if (varName0Exists) {
                                        //if (line.length == 6) {
                                        //    //addLine("LINE.LENGTH==6");
                                        //    tokenList[varName0Index].value = evaluateExpression(line[3], line[4], line[5], tokenList);
                                        //}
                                        //else if (!varName1IsVariable) {
                                        //    //addLine("!VARNAME1ISVARIABLE");
                                        //    tokenList[varName0Index].value = var1;
                                        //}
                                        //else if (varNamevarName1Exists) {
                                        //    //addLine("VARNAME1EXISTS");
                                        //    tokenList[varName0Index].value = tokenList[varName1Index].value;
                                        //}
                                        //else {
                                        //    addLine("VARIABLE2 NAME '$" + varName1 + "' ON LINE " + (i + 1) + " DOES NOT EXIST.");
                                        //    i = currentScript.length;
                                        //}

                                        var tempExp = "";
                                        for (var j = 3; j < line.length; j++) {
                                            tempExp += line[j];
                                        }
                                        //addLine("Processing LET with " + tempExp);
                                        tokenList[varName0Index].value = evaluateExpression(tempExp, tokenList);
                                    }
                                    else {
                                        addLine("VARIABLE1 NAME '$" + varName0 + "' ON LINE " + (i + 1) + " DOES NOT EXIST.");
                                        //for (var k = 0; k < line.length; k++) {
                                        //    addLine("WORD" + k + " = " + line[k]);
                                        //}
                                        i = currentScript.length;
                                    }

                                    //if (varName0Exists && varName1Exists) {
                                    //    if (varName1IsVariable) {
                                    //        tokenList[varName0Index].value = var1;
                                    //        //addLine("tokenList[" + varName0Index + "] = { " + tokenList[varName0Index].key + ", " + tokenList[varName0Index].value + "};");
                                    //    } else {
                                    //        tokenList[varName0Index].value = tokenList[varName1Index].value;
                                    //        //addLine("tokenList[" + varName0Index + "] = { " + tokenList[varName0Index].key + ", " + tokenList[varName0Index].value + "};");
                                    //    }
                                    //}
                                    //else {
                                    //    if (!varName0Exists) {
                                    //        addLine("VARIABLE1 NAME '$" + varName0 + "' ON LINE " + (i + 1) + " DOES NOT EXIST.");
                                    //        //for (var k = 0; k < line.length; k++) {
                                    //        //    addLine("WORD" + k + " = " + line[k]);
                                    //        //}
                                    //        i = currentScript.length;
                                    //    }
                                    //    else if (!varName1IsVariable) {
                                    //        tokenList[varName0Index].value = var1;
                                    //        //addLine("tokenList[" + varName0Index + "] = { " + tokenList[varName0Index].key + ", " + tokenList[varName0Index].value + "};");
                                    //    }
                                    //    if (!varName1Exists && varName1IsVariable) {
                                    //        addLine("VARIABLE2 NAME '$" + varName1 + "' ON LINE " + (i + 1) + " DOES NOT EXIST.");
                                    //        i = currentScript.length;
                                    //    }
                                    //}
                                } else {
                                    addLine("INVALID OPERATOR ON LINE " + (i + 1) + ".");
                                    i = currentScript.length;
                                }
                            }
                            else {
                                addLine("AN ERROR OCCURRED ON LINE " + (i + 1) + " OF " + params[1] + ".");
                                i = currentScript.length;
                            }
                        }
                    }
                    else {
                        addLine("SYNTAX ERROR.");
                    }

                    tokenList = [];
                }

                programLoaded = false;

                //how do I allow user input inside programs?
            };

            var registerCommand = function (text) {
                var matched = false;
                var params = text.split(' ');
                for (var i = 0; (i < commands.length) && (!matched); i++) {
                    if (params[0] == commands[i]) {
                        executeCommand(text);
                        matched = true;
                    }
                }
                if (!matched) {
                    addLine("SYNTAX ERROR.");
                }
            };

            // Capture keypress
            // from http://stackoverflow.com/questions/3729034/javascript-html5-capture-keycode-and-write-to-canvas
            // Had to switch .onkeypress event to .onkeydown so as to capture backspace.
            //var keypressHandled = false;
            terminal.onkeypress = function (evt) {
                //keyPressHandled = true;
                var charCode = evt.which;
                if (!programControl) {
                    if (charCode == 13) {
                        addLine(currentPath + "> " + currentLine);
                        registerCommand(currentLine);
                        currentLine = "";
                    } else if (charCode >= 32) {
                        // No reason to handle arrow keys separately here since they don't invoke the onKeyPress event
                        var charStr = String.fromCharCode(charCode);
                        currentLine += charStr;
                    } else {
                        //currentLine = charCode;
                    }
                }
                else {
                    interrupt = charCode;
                    evt.preventDefault();
                }
            };

            terminal.onkeydown = function (evt) {
                var charCode = evt.which;
                if (!programControl) {
                    if (charCode == 8) {
                        currentLine = currentLine.substring(0, currentLine.length - 1);
                        evt.preventDefault();
                    }
                    else if (charCode == 32) {
                        currentLine += " ";
                        evt.preventDefault();
                    }
                    //else if ((charCode > 36) && (charCode < 41)) {
                    //    // left is 37, up is 38, right is 39, and down is 40
                    //}
                    else if (charCode == 27) {
                        //fgColor = "#FF0000";
                        interrupt = charCode;
                    }
                    else {
                        // I'll let the interrupt handle the arrow keys.
                        interrupt = charCode;
                    }
                }
                else {
                    if (charCode == 27) {
                        //fgColor = "#FF0000";
                        interrupt = charCode;
                        evt.preventDefault();
                    }
                    else if (charCode == 8 || charCode == 32) {
                        interrupt = charCode;
                        evt.preventDefault();
                    }
                    else if (charCode == 46) {
                        interrupt = 15;
                        evt.preventDefault();
                    }
                    else if (charCode == 37 || charCode == 38 || charCode == 39 || charCode == 40) {
                        interrupt = charCode;
                        evt.preventDefault();
                    }
                    else {
                        //interrupt = charCode;
                        //evt.preventDefault();
                    }
                }
            };

            // copied from http://ux.stackexchange.com/questions/53176/why-does-backspace-go-back-a-page-this-behavior-is-so-frustrating
            var terminalFocus = 'false';
            // when focus happens, set a variable
            //$(document).on('focusin', 'input, textarea', function () {
            //    terminalFocus = 'true';
            //});
            // if not in a form field, stop backspace and delete default action
            //$(document).keypress(function (e) {
            //    if (e.which == 8 || e.which == 46) {
            //        if (terminalFocus == 'false') {
            //            e.preventDefault();
            //        }
            //    }
            //});

        </script>

        <div>
            <input type="button" id="btnRequest" onclick="dbRequest('LOOP')" value="Sample Script" />
            <!--
            <br />
            <script>
                var splitTest = function () {
                    var t = document.getElementById('txtResponse');
                    var s = '/programs/cobol_src';
                    var sArray = s.split('/');
                    t.value = sArray.length;
                    alert('---' + sArray[0] + '---');
                };
            </script>
            <input type="button" id="btnRequest" onclick="splitTest()" value="Split test" />
            <br />
            <input type="button" id="btnRequest" onclick="batch(['BATCH', 'IF.BAT', '3', '7'])" value="Batch test" />
            <br />
            <input type="button" id="btnRequest" onclick="function () { document.getElementById('txtResponse').value = currentPath; }" value="Print currentPath" />
            <br />
            <input type="text" id="txtResponse" style="width: 800px;"></input>
            -->
        </div>
        <!-- OSJS: Version 0.1 -->
    </body>
</html>
